var ansi = require('ansi-escapes');
var chalk = require('chalk');

module.exports = exports.default = function emailPropt(ref) {
  if ( ref === void 0 ) ref = {};
  var ref_start = ref.start, start = ref_start === void 0 ? '> Enter your email: ' : ref_start;
  var ref_domains = ref.domains, domains = ref_domains === void 0 ? new Set([
    'aol.com',
    'gmail.com',
    'google.com',
    'yahoo.com',
    'ymail.com',
    'hotmail.com',
    'live.com',
    'outlook.com',
    'inbox.com',
    'mail.com',
    'gmx.com'
  ]) : ref_domains;
  var ref_forceLowerCase = ref.forceLowerCase, forceLowerCase = ref_forceLowerCase === void 0 ? true : ref_forceLowerCase;
  var ref_suggestionColor = ref.suggestionColor, suggestionColor = ref_suggestionColor === void 0 ? 'gray' : ref_suggestionColor;
  var ref_autoCompleteChars = ref.autoCompleteChars, autoCompleteChars = ref_autoCompleteChars === void 0 ? new Set([
    '\t' /* tab */,
    '\r' /* return */,
    '\u001b[C' /* right arrow */,
    ' ' /* spacebar */
  ]) : ref_autoCompleteChars;
  var ref_resolveChars = ref.resolveChars, resolveChars = ref_resolveChars === void 0 ? new Set(['\r']) : ref_resolveChars;
  var ref_abortChars = ref.abortChars, abortChars = ref_abortChars === void 0 ? new Set(['\u0003']) : ref_abortChars;
  var ref_allowInvalidChars = ref.allowInvalidChars, allowInvalidChars = ref_allowInvalidChars === void 0 ? false : ref_allowInvalidChars;

  return new Promise(function (resolve, reject) {
    var isRaw = process.stdin.isRaw;
    var isPaused = process.stdin.isPaused();

    process.stdout.write(start);
    process.stdin.setRawMode(true);
    process.stdin.resume();

    var val = '';
    var suggestion = '';
    var caretOffset = 0;

    // to make `for..of` work with buble
    var _domains = Array.from(domains);

    var ondata = function (v) {
      var s = v.toString();

      // abort upon ctrl+C
      if (abortChars.has(s)) {
        restore();
        return reject(new Error('User abort'));
      }

      var completion = '';

      // if we have a suggestion *and*
      // the user is at the end of the line *and*
      // the user pressed one of the keys to trigger completion
      if (suggestion !== '' && !caretOffset && autoCompleteChars.has(s)) {
        val += suggestion;
        suggestion = '';
      } else {
        if ('\u001b[D' === s) {
          if (val.length > Math.abs(caretOffset)) {
            caretOffset--;
          }
        } else if ('\u001b[C' === s) {
          if (caretOffset < 0) {
            caretOffset++;
          }
        } else if ('\x08' === s || '\x7f' === s) {
          // delete key needs splicing according to caret position
          val = val.substr(0, val.length + caretOffset - 1) +
            val.substr(val.length + caretOffset);
        } else {
          if (resolveChars.has(s)) {
            restore();
            return resolve(val);
          }

          if (!allowInvalidChars) {
            // disallow more than one @
            if (/@/.test(val) && '@' === s) {
              return;
            }

            if (/[^A-z0-9-+_.@]/.test(s)) {
              return;
            }
          }

          var add = forceLowerCase ? s.toLowerCase() : s;
          val = val.substr(0, val.length + caretOffset) + add +
            val.substr(val.length + caretOffset);
        }

        var parts = val.split('@');
        if (2 === parts.length && parts[1].length) {
          var _host = parts[1];
          var host = _host.toLowerCase();
          for (var i = 0, list = _domains; i < list.length; i += 1) {
            var domain = list[i];

            if (host === domain) {
              break;
            }

            if (host === domain.substr(0, host.length)) {
              suggestion = domain.substr(host.length);
              completion = chalk[suggestionColor](suggestion);
              completion += ansi.cursorBackward(domain.length - host.length);
              break;
            }
          }
        }

        if (!completion.length) suggestion = '';
      }

      process.stdout.write(ansi.eraseLines(1) + start + val + completion);
      if (caretOffset) {
        process.stdout.write(ansi.cursorBackward(Math.abs(caretOffset)));
      }
    };

    var restore = function () {
      process.stdin.setRawMode(isRaw);
      process.stdin.pause();
      process.stdin.removeListener('data', ondata);
    };

    process.stdin.on('data', ondata);
  });
}

